# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-minitest` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module RuboCop
end

module RuboCop::Cop
end

module RuboCop::Cop::ArgumentRangeHelper
  include(::RuboCop::Cop::RangeHelp)


  private

  def all_arguments_range(node); end
  def first_and_second_arguments_range(node); end
  def first_argument_range(node); end
end

module RuboCop::Cop::InDeltaMixin
  def autocorrect(node); end
  def on_send(node); end

  private

  def assertion_method; end
  def build_good_method(expected, actual, message); end
end

RuboCop::Cop::InDeltaMixin::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Minitest
end

class RuboCop::Cop::Minitest::AssertEmpty < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertEmpty::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertEmptyLiteral < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def assert_with_empty_literal(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Minitest::AssertEmptyLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertEqual < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertEqual::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertInDelta < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::InDeltaMixin)

  def equal_floats_call(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Minitest::AssertIncludes < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertIncludes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertInstanceOf < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertInstanceOf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertKindOf < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertKindOf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertMatch < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertMatch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertNil < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def assert_equal_with_nil(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Minitest::AssertNil::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertOutput < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::MinitestExplorationHelpers)

  def on_gvasgn(node); end

  private

  def find_test_case(node); end
  def references_gvar?(assertion, gvar_name); end
end

RuboCop::Cop::Minitest::AssertOutput::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Minitest::AssertOutput::OUTPUT_GLOBAL_VARIABLES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Minitest::AssertPathExists < ::RuboCop::Cop::Cop
  def assert_file_exists(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end

  private

  def build_good_method(path, message); end
end

RuboCop::Cop::Minitest::AssertPathExists::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertRespondTo < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::AssertRespondTo::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertSilent < ::RuboCop::Cop::Cop
  def assert_silent_candidate?(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_block(node); end

  private

  def empty_string?(node); end
end

RuboCop::Cop::Minitest::AssertSilent::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertTruthy < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def assert_equal_with_truthy(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Minitest::AssertTruthy::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::AssertionInLifecycleHook < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::MinitestExplorationHelpers)

  def on_class(class_node); end
end

RuboCop::Cop::Minitest::AssertionInLifecycleHook::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::GlobalExpectations < ::RuboCop::Cop::Cop
  def autocorrect(node); end
  def block_global_expectation?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def value_global_expectation?(param0 = T.unsafe(nil)); end

  private

  def preferred_receiver(node); end
end

RuboCop::Cop::Minitest::GlobalExpectations::BLOCK_MATCHERS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Minitest::GlobalExpectations::BLOCK_MATCHERS_STR = T.let(T.unsafe(nil), String)

RuboCop::Cop::Minitest::GlobalExpectations::DSL_METHODS_LIST = T.let(T.unsafe(nil), String)

RuboCop::Cop::Minitest::GlobalExpectations::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Minitest::GlobalExpectations::VALUE_MATCHERS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Minitest::GlobalExpectations::VALUE_MATCHERS_STR = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::LiteralAsActualArgument < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Minitest::LiteralAsActualArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::MultipleAssertions < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::ConfigurableMax)
  include(::RuboCop::Cop::MinitestExplorationHelpers)

  def on_class(class_node); end

  private

  def assertions_count(node); end
  def max_assertions; end
end

RuboCop::Cop::Minitest::MultipleAssertions::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteEmpty < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteEmpty::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteEqual < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def assert_not_equal(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end

  private

  def original_usage(first_part, custom_message); end
  def preferred_usage(first_arg, second_arg, custom_message = T.unsafe(nil)); end
  def process_not_equal(node); end
end

RuboCop::Cop::Minitest::RefuteEqual::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteFalse < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def assert_equal_with_false(param0 = T.unsafe(nil)); end
  def assert_with_bang_argument(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Minitest::RefuteFalse::MSG_FOR_ASSERT = T.let(T.unsafe(nil), String)

RuboCop::Cop::Minitest::RefuteFalse::MSG_FOR_ASSERT_EQUAL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteInDelta < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::InDeltaMixin)

  def equal_floats_call(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Minitest::RefuteIncludes < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteIncludes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteInstanceOf < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteInstanceOf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteKindOf < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteKindOf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteMatch < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteMatch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteNil < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)

  def autocorrect(node); end
  def on_send(node); end
  def refute_equal_with_nil(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Minitest::RefuteNil::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefutePathExists < ::RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def refute_file_exists(param0 = T.unsafe(nil)); end

  private

  def build_good_method(path, message); end
end

RuboCop::Cop::Minitest::RefutePathExists::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::RefuteRespondTo < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ArgumentRangeHelper)
  extend(::RuboCop::Cop::MinitestCopRule)

  def autocorrect(node); end
  def on_send(node); end

  private

  def correct_receiver(receiver); end
  def enclosed_in_redundant_parentheses?(node); end
  def new_arguments(arguments); end
  def offense_message(arguments); end
  def peel_redundant_parentheses_from(arguments); end
end

RuboCop::Cop::Minitest::RefuteRespondTo::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::TestMethodName < ::RuboCop::Cop::Cop
  include(::RuboCop::Cop::MinitestExplorationHelpers)
  include(::RuboCop::Cop::DefNode)

  def autocorrect(node); end
  def on_class(class_node); end

  private

  def class_elements(class_node); end
  def offense?(node); end
  def public?(node); end
  def test_method_name?(node); end
end

RuboCop::Cop::Minitest::TestMethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Minitest::UnspecifiedException < ::RuboCop::Cop::Cop
  def on_block(block_node); end

  private

  def unspecified_exception?(node); end
end

RuboCop::Cop::Minitest::UnspecifiedException::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::MinitestCopRule
  def define_rule(assertion_method, target_method:, preferred_method: T.unsafe(nil), inverse: T.unsafe(nil)); end
end

module RuboCop::Cop::MinitestExplorationHelpers
  extend(::RuboCop::AST::NodePattern::Macros)


  private

  def assertion?(node); end
  def assertion_method?(method_name); end
  def assertions(def_node); end
  def class_def_nodes(class_node); end
  def lifecycle_hook_method?(node); end
  def lifecycle_hooks(class_node); end
  def test_case?(node); end
  def test_case_name?(name); end
  def test_cases(class_node); end
  def test_class?(class_node); end
end

RuboCop::Cop::MinitestExplorationHelpers::ASSERTION_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::MinitestExplorationHelpers::ASSERTION_PREFIXES = T.let(T.unsafe(nil), Array)

RuboCop::Cop::MinitestExplorationHelpers::LIFECYCLE_HOOK_METHODS = T.let(T.unsafe(nil), Set)

module RuboCop::Minitest
end

RuboCop::Minitest::CONFIG = T.let(T.unsafe(nil), Hash)

module RuboCop::Minitest::Inject
  class << self
    def defaults!; end
  end
end

module RuboCop::Minitest::Version
  class << self
    def document_version; end
  end
end

RuboCop::Minitest::Version::STRING = T.let(T.unsafe(nil), String)

RuboCop::NodePattern = RuboCop::AST::NodePattern

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

RuboCop::Token = RuboCop::AST::Token
